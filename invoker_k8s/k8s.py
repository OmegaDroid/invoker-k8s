import logging
import shutil
import yaml
from os.path import join
from tempfile import NamedTemporaryFile, TemporaryDirectory

from invoke import task, run

from .kustomize import kustomize
from .configure import config

logger = logging.getLogger(__file__)


def run_kubectl(ctx, cmd):
    kubectl_exe = ctx.get('kubectl_exe', 'kubectl')
    run('{kubectl_exe} {cmd}'.format(
        kubectl_exe=kubectl_exe,
        cmd=cmd,
    ))


@task(help={
    'kustomize-path': 'Overrides the kustomize build path, if not set the path from the context is used',
    'dry-run': 'Print updated config to console rather than applying.'
})
def apply(ctx, kustomize_path=None, dry_run=False):
    """
    Applies the configuration generated by kustomize
    """
    config(ctx)

    with NamedTemporaryFile() as f:
        kustomize(ctx, output_file=f.name, path=kustomize_path)

        if not dry_run:
            run_kubectl(ctx, 'apply -f {fname}'.format(fname=f.name,))
        else:
            print(f.read().decode())


@task(help={
    'label': 'The name of the image to deploy.',
    'dry-run': 'Print updated config to console rather than applying.'
})
def deploy(ctx, label, dry_run=False):
    """
    Updates the kubernetes config with the new image
    """
    config(ctx)

    kustomize_root = ctx.get('kustomize_root', 'k8s')

    with TemporaryDirectory() as d:
        build_path = join(d, ctx.get('kustomize_path', join(kustomize_root, 'overlays', ctx['env'])))
        config_path = join(d, build_path, 'kustomization.yaml')

        shutil.copytree(kustomize_root, join(d, kustomize_root))

        with open(config_path) as f:
            kustomization = yaml.load(f)

        images = kustomization.get('images', [])

        for image in images:
            if image['name'] in ctx.get('kustomize_deploy_images', []):
                image['newTag'] = label

        kustomization['images'] = images

        with open(config_path, 'w') as f:
            yaml.dump(kustomization, f)

        apply(ctx, kustomize_path=build_path, dry_run=dry_run)
